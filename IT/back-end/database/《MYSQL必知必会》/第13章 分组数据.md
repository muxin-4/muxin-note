# 第13章 分组数据

>  分组数据涉及两个GROUPSELECT语句子句， 分别是GROUP BY 子句和HAVING 子句。

## 13.1 数据分组

下面的例子返回供应商1003 提供的产品数目

```
SELECT COUNT(*) AS num_prods
FROM products
WHERE vend_id = 1003;
```



**但如果要返回每个供应商提供的产品数目怎么办？或者返回只提供单项产品的供应商所提供的产品，或返回提供10 个以上产品的供应商怎么办？**

这就是分组显身手的时候了。分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。



## 13.2 创建分组

```
SELECT vend_id, COUNT(*) AS num_prods
FROM products
GROUP BY vend_id;
```

**输出**
+---------------+-------------+
|   vend_id  |           3   |
+---------------+-------------+
|        1001  |           3   |
|        1002  |           2   |
|        1003  |           7   |
|        1005  |           2   |



上面的SELECT 语句指定了两个列，vend_id 包含产品供应商的ID ，num_prods 为计算字段（用COUNT(*) 函数建立）。GROUP BY 子句指示MySQL 按vend_id 排序并分组数据。这导致对每个vend_id 而不是整个表计算num_prods 一次。从输出中可以看到，供应商1001 有3 个产品，供应商1002 有2 个产品，供应商1003 有7 个产品，而供应商1005 有2 个产品。

## 13.3 过滤分组

怎么过滤分组呢？请看以下的例子：

```
SELECT cust_id, COUNT(*) AS orders
FROM orders
GROUP BY cust_id
HAVING COUNT(*) >=2
```

**输出**
+---------------+-------------+
|   cust_id   |           2   |
+---------------+-------------+
|      10001 |           2   |

这条SELECT 语句的前3 行类似于上面的语句。最后一行增加了HAVING 子句，它过滤COUNT(*) >=2 （两个以上的订单）的那些分组。

**这里WHERE 子句不起作用，因为过滤是基于分组聚集值而不是特定行值的。**

**注**

这里有另一种理解方法，WHERE 在数据分组前进行过滤，HAVING 在数据分组后进行过滤。这是一个重要的区别，WHERE 排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING 子句中基于这些值过滤掉的分组。

**那么，有没有在一条语句中同时使用WHERE 和HAVING 子句的需要呢？**

事实上，确实有。假如想进一步过滤上面的语句，使它返回过去12 个月内具有两个以上订单的顾客。

```
SELECT vend_id, COUNT(*) AS num_prods
FROM products
WHERE prod_price >= 10
GROUP BY vend_id
HAVING COUNT(*) >= 2
```

**输出**
+---------------+----------------------+
|   vend_id   |    num_prods  |
+---------------+----------------------+
|      1003    |                      4   |

|      1005    |                      2   |

+---------------+----------------------+

这条语句中，第一行是使用了聚集函数的基本SELECT ，它与前面的例子很相像。WHERE 子句过滤所有prod_price 至少为10 的行。然后按vend_id 分组数据，HAVING 子句过滤计数为2 或2 以上的分组。如果没有WHERE 子句，将会多检索出两行（供应商1002 ，销售的所有产品价格都在10 以下；供应商1001 ，销售3 个产品，但只有一个产品的价格大于等于10)。



## 13.4 分组和排序

**不要忘记ORDER BY**

一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万

不要仅依赖GROUP BY排序数据。

**示例**

```
SELECT order_num, SUM(quantity*item_price) AS ordertotal
FROM orderitems
GROUP BY order_num
HAVING SUM(quantity * item_price) >= 50
ORDER BY ordertotal;
```

**输出**
+---------------------+----------------------+
|   order_num   |      ordertotal   |
+---------------------+----------------------+
|             20006  |  55.00               |
|             20008  |  125.00             |
|             20005  |  149.87             |
|             20007  |  1000.00           |

+---------------------+----------------------+



## 13.5 SELECT子句顺序

下面回顾一下SELECT 语句中子句的顺序。

| 子  句 |       说  明       | 是否必须使用  |
| :----: | :----------------: | :----------------:  |
| SELECT | 要返回的列或表达式 | 是 |
| FROM | 从中检索数据的表 | 仅在从表选择数据时使用 |
| WHERE | 行级过滤 | 否 |
| GROUP BY | 分组说明 | 仅在按组计算聚集时使用 |
| HAVING | 组级过滤 | 否 |
| ORDER BY | 输出排序顺序 | 否 |
| LIMIT | 要检索的行数 | 否 |

