# 第15章 连结表

## 15.1 联结

**SQL最强大的功能之一就是能在数据检索查询的执行中联结（ join）表。联结是利用 SQL的SELECT能执行的最重要的操作，很好地理解联结及其语法是学习 SQL的一个极为重要的组成部分。**

### 15.1.1 创建连接

```
SELECT vend_name, prod_name, prod_price
FROM vendors, products
WHERE vendors.vend_id = products.vend_id
ORDER BY vend_name, prod_name;
```

我们来考察一下此代码。SELECT 语句与前面所有语句一样指定要检索的列。这里，最大的差别是所指定的两个列（prod_name和prod_price ）在一个表中，而另一个列（vend_name ）在另一个表中。现在来看FROM 子句。与以前的SELECT 语句不一样，这条语句的FROM子句列出了两个表，分别是vendors 和products 。它们就是这条SELECT 语句联结的两个表的名字。这两个表用WHERE 子句正确联结，WHERE 子句指示MySQL 匹配vendors 表中的vend_id 和products 表中的vend_id 。可以看到要匹配的两个列以vendors.vend_id  和products.vend_id 指定。这里需要这种完全限定列名，因为如果只给出vend_id ，则MySQL 不知道指的是哪一个（它们有两个，每个表中一个）。



**不要忘了WHERE 子句**

**应该保证所有联结都有WHERE 子句，否则MySQL 将返回比想要的数据多得多的数据。同理，应该保证WHERE 子句的正确性。不正确的过滤条件将导致MySQL 返回不正确的数据。**



### 15.1.2 内部联结

目前为止所用的联结称为等值联结 （equijoin ），它基于两个表之间的相等测试。这种联结也称为内部联结 。其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。下面的SELECT 语句返回与前面例子完全相同的数据：

```
SELECT vend_name, prod_name, prod_price
FROM vendors INNER JOIN products
ON vendors.vend_id = products.vend_id;
```

此语句中的SELECT 与前面的SELECT 语句相同，但FROM 子句不同。

**使用哪种语法 **

ANSI SQL规范首选INNER JOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。

### 15.1.3 联结多个表

```
SELECT prod_name, vend_name, prod_price, quantity
FROM orderitems, products, vendors
WHERE products.vend_id = vendors.vend_id
	AND orderitems.prod_id = products.prod_id
	AND order_num = 20005;
```

**分析**

此例子显示编号为20005 的订单中的物品。订单物品存储在orderitems 表中。每个产品按其产品ID 存储，它引用products表中的产品。这些产品通过供应商ID 联结到vendors 表中相应的供应商，供应商ID 存储在每个产品的记录中。这里的FROM 子句列出了3 个表，而WHERE 子句定义了这两个联结条件，而第三个联结条件用来过滤出订单20005 中的物品。



